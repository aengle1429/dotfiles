Headers are just preprocessor magic. Never include source, but include struct definitions and function declarations in there.

#define is literally text replacement. won't #define MAX 1 won't replace MAXMIN
'\0', NULL and 0 are all literal zero bits
if we declare int y[3]; then set p = &y[1] we can do p + 1 and this moves p + sizeof(int) bytes forward in memory

fgets reads one less than input size from file.
-E does preprocessor, but maybe it isn't what Hal did.

Only #include in header files if the header itself needs them!

should do sizeof(variable name) not sizeof(type), so don't do sizeof(int), do int* arr = (int *) malloc(sizeof(*arr) * count)

no such thing as strnlen in C I think.

changing int * x within some function, like x = NULL will not change x outside of the function.

Can't just assign an array of chars as a field and then update the array of chars as you process the file!
    This was a bug I had: trie.words[0] = word, but then fgets overwrites the string that word points to! need to copy.

Header files are not compiled. We compile the .c files that include them. They are read during that process by the preprocessor.

scanf ignores whitespace and newlines!

A[M][N]
M * N things held, but this is row-major. Then
A[i][j] is valid for 0<=i<M and 0<=j<N
i.e., this is the standard matrix notation!

A[i] is an array of length N! (the row vectors). In memory, should look like
A[0] A[1] A[2] ... A[M-1]

row-major orientation, so each A[i] is a row vector of stuff.
A[0][0] A[0][1] A[0][2] ... A[0][N-1] A[1][0] ...

argc is 1 + number of commandline args
argc is also equal to the number of strings pointed to by argv
name of file is prepended to the array

Compiling just converts to bytes. Do not need to include other functions defined in another .c file  when doing gcc -c file.c, if file.c has calls to a function in file2.c!
